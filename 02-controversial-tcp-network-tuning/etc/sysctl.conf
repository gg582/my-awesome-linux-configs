## Forward IPv4 IP Address to use it inside of k8s
net.ipv4.ip_forward=1
## Enlarge the transfer window
net.ipv4.tcp_window_scaling=1
## rmem affects more to modern socket applications
net.core.rmem_max=25165820
net.core.wmem_max=20971520

## More agressive TCP RMEM and WMEM
## Slightly lower wmem to prevent Write overhead
## Loopback has quite small network delay, so overly repetitive write task can cause overhead
## This is my solution to prevent that problem;
## 24 Mebibyte
net.ipv4.tcp_rmem=4096    131072  25165820
## 20 Mebibyte
net.ipv4.tcp_wmem=4096    131072  20971520
## This is controversial.
## This is not good for usual cases
## So it should be setted up for specific edge cases while sacrificing modern applications
net.ipv4.tcp_no_metrics_save=1
## Follow RFC1323
net.ipv4.tcp_timestamps=1
## Very big input packet buffer to prevent packet loss
## Don't try this for embedded devices
net.core.netdev_max_backlog=65536

## DO NOT USE THIS ON MEMORY INSUFFICIENT ENVIRONMENTS
vm.swappiness = 10
vm.dirty_ratio=60

## Decrease TCP Fin Timeout. This is much controversial
net.ipv4.tcp_fin_timeout=10
## --WARNING-- THIS USES LESS KEEPALIVE TIME! 
net.ipv4.keepalive_time=250
net.ipv4.tcp_keepalive_probes=4
## Get more incoming connections while decreasing TCP FIN Timeout
net.core.somadconn = 65535

## Increase TCP-Time-Wait buckets
net.ipv4.tcp_max_tw_buckets=1440000
## Deprecated Option
net.ipv4.tcp_tw_recycle=1
net.ipv4.tcp_tw_reuse=1
